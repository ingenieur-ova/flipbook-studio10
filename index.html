<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flipbook A4 – drag only, auto pages</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/css/page-flip.css">
  <style>
    :root {
      --book-max-w: 1100px;
      --ar-landscape: calc(420 / 297); /* 2 pages A4 côte à côte */
      --ar-portrait:  calc(210 / 297); /* 1 page A4 */
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; min-height: 100vh; display: grid; place-items: center;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: #fff; color: #111;
    }
    .wrap { width: min(96vw, var(--book-max-w)); }
    .toolbar {
      display: flex; gap: .5rem; align-items: center; justify-content: space-between;
      margin-bottom: .5rem; flex-wrap: wrap;
    }
    .btn {
      border: 1px solid #ddd; border-radius: 10px; padding: .6rem .9rem; cursor: pointer;
      background: #fff; color: #111; font-weight: 600; box-shadow: 0 2px 6px rgba(0,0,0,.06);
    }
    .btn:active { transform: translateY(1px); }
    #book {
      width: 100%;
      aspect-ratio: var(--ar-landscape); /* par défaut : double page */
      border-radius: 14px; overflow: hidden;
      background: #fff; box-shadow: 0 10px 30px rgba(0,0,0,.15);
      user-select: none; -webkit-user-drag: none;
    }
    #book.is-portrait { aspect-ratio: var(--ar-portrait); }
    @media (max-width: 820px) { #book { aspect-ratio: var(--ar-portrait); } }

    .hint { opacity: .7; font-size: .9rem; margin-top: .4rem }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="toolbar">
      <div>
        <button class="btn" id="prev">◀ Précédent</button>
        <button class="btn" id="next">Suivant ▶</button>
        <button class="btn" id="fullscreen">⛶ Plein écran</button>
      </div>
      <!-- (compteur supprimé) -->
    </div>

    <div id="book"></div>

   <!-- <div class="hint">Glisser (drag) au centre pour tourner • Clics désactivés sur la page • Utilise les boutons ou les flèches ← →</div> -->
   <!-- </div> -->

  <script src="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/js/page-flip.browser.min.js"></script>
  <script>
    (function () {
      // ====== PARAMÈTRES DÉPÔT ======
      const owner  = 'ingenieur-ova';
      const repo   = 'flipbook-studio10';
      const branch = 'main';
      const folder = 'images';
      const baseURL = `https://${owner}.github.io/${repo}/${folder}`;

      // ====== OUTILS ======
      function sortByNumericName(files) {
        const rx = /^(\d{1,3})\.(jpg|jpeg|png|webp)$/i;
        return files
          .map(name => {
            const m = name.match(rx);
            return m ? { n: parseInt(m[1],10), name, ext: m[2].toLowerCase() } : null;
          })
          .filter(Boolean)
          .sort((a,b)=> a.n - b.n);
      }

      async function listImagesViaGitHubAPI() {
        const api = `https://api.github.com/repos/${owner}/${repo}/contents/${folder}?ref=${branch}`;
        const res = await fetch(api, { headers: { 'Accept':'application/vnd.github.v3+json' }});
        if (!res.ok) throw new Error('GitHub API error: '+res.status);
        const json = await res.json();
        const names = json.filter(x=>x.type==='file').map(x=>x.name);
        const sorted = sortByNumericName(names);
        if (!sorted.length) throw new Error('Aucune image reconnue');
        return sorted.map(x => `${baseURL}/${x.name}`);
      }

      function probe(url) {
        return new Promise(resolve => {
          const img = new Image();
          img.onload = () => resolve(url);
          img.onerror = () => resolve(null);
          img.src = url + '?v=' + Date.now();
        });
      }
      async function listImagesByScanning(max = 199) {
        const exts = ['jpg','jpeg','png','webp'];
        const urls = [];
        for (let i=1;i<=max;i++) {
          const nn = String(i).padStart(2,'0');
          let found = null;
          for (const ext of exts) {
            const u = `${baseURL}/${nn}.${ext}`;
            // eslint-disable-next-line no-await-in-loop
            const ok = await probe(u);
            if (ok) { found = ok; break; }
          }
          if (found) urls.push(found);
          else if (urls.length) break;
        }
        if (!urls.length) throw new Error('Scan: aucune image trouvée');
        return urls;
      }

      async function buildURLList() {
        try { return await listImagesViaGitHubAPI(); }
        catch { return await listImagesByScanning(); }
      }

      // ====== INIT PAGEFLIP ======
      const bookEl = document.getElementById('book');

      const pageWidth  = 595;   // 1 page A4 ~72dpi
      const pageHeight = 842;

      const pageFlip = new St.PageFlip(bookEl, {
        width: pageWidth,
        height: pageHeight,
        size: 'stretch',
        minWidth: 320,
        minHeight: 320,
        maxShadowOpacity: 0.2,
        flippingTime: 600,
        showCover: true,
        usePortrait: true,       // mode simple page auto si étroit
        mobileScrollSupport: false
      });

      function syncOrientationClass() {
        const isPortrait = pageFlip.getOrientation && pageFlip.getOrientation() === 'portrait';
        bookEl.classList.toggle('is-portrait', !!isPortrait);
      }
      pageFlip.on('init', syncOrientationClass);
      pageFlip.on('changeOrientation', syncOrientationClass);

      // ====== CHARGEMENT IMAGES ======
      (async () => {
        try {
          const urls = await buildURLList();
          pageFlip.loadFromImages(urls);
        } catch (e) {
          console.error(e);
          alert("Erreur: impossible de charger les images.");
        }
      })();

      // ====== COMMANDES ======
      document.getElementById('prev').onclick = () => pageFlip.flipPrev();
      document.getElementById('next').onclick = () => pageFlip.flipNext();
      document.getElementById('fullscreen').onclick = () => {
        if (!document.fullscreenElement) bookEl.requestFullscreen?.();
        else document.exitFullscreen?.();
      };
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft')  pageFlip.flipPrev();
        if (e.key === 'ArrowRight') pageFlip.flipNext();
      });

      // ====== DRAG OUI, CLICS SUR LA PAGE NON ======
      // On bloque tout "click" sur #book en phase capture, sans toucher au drag.
      const kill = (e)=>{ e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation?.(); };
      bookEl.addEventListener('click', kill, true);
      bookEl.addEventListener('dblclick', kill, true);
      bookEl.addEventListener('auxclick', kill, true);

      // Important : on n'ajoute AUCUN overlay ni handler pointerdown/up => drag natif intact.
      // Les seuls clics possibles sont sur les boutons (Précédent/Suivant) ou via clavier.
    })();
  </script>
</body>
</html>